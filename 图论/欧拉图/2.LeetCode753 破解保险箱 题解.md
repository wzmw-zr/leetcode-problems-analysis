# LeetCode753 破解保险箱 题解

## 一、题目描述

有一个需要密码才能打开的保险箱。密码是 `n` 位数, 密码的每一位都是范围 `[0, k - 1]` 中的一个数字。

保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 **最后 `n` 位输入** ，如果匹配，则能够打开保险箱。

- 例如，正确的密码是"345" ，并且你输入的是"012345"：
  - 输入 `0` 之后，最后 `3` 位输入是 `"0"` ，不正确。
  - 输入 `1` 之后，最后 `3` 位输入是 `"01"` ，不正确。
  - 输入 `2` 之后，最后 `3` 位输入是 `"012"` ，不正确。
  - 输入 `3` 之后，最后 `3` 位输入是 `"123"` ，不正确。
  - 输入 `4` 之后，最后 `3` 位输入是 `"234"` ，不正确。
  - 输入 `5` 之后，最后 `3` 位输入是 `"345"` ，正确，打开保险箱。

在只知道密码位数 `n` 和范围边界 `k` 的前提下，请你找出并返回确保在输入的 **某个时刻** 能够打开保险箱的任一 **最短** 密码序列 。



## 二、分析

### 1. 欧拉图 + Hierholzer算法

这是欧拉图的典型题目，**关键在于如何建模，题目希望找到一串数字包含所有n位的[0,k-1]的数字，这种题目设顶点为n-1位的数字，顶点之间的边是一个数字，因此一个顶点的入度和出度都为k，一定存在欧拉回路**。随便选一个顶点作为起点跑Hierholzer算法即可，边序列需要rerverse，在前面加上起点的数字即可。



## 三、代码

### 1. 欧拉图 + Hierholzer算法

```c++
string crackSafe(int n, int k) {
  unordered_set<int> st;
  int MOD = pow(10, n - 1);
  string ans = "";
  function<void(int)> dfs = [&](int node) -> void {
    for (int i = 0; i < k; i++) {
      int edge = node * 10 + i;
      if (!st.count(edge)) {
        st.insert(edge);
        dfs(edge % MOD);
        ans += '0' + i;
      }
    }
  };
  dfs(0);
  reverse(ans.begin(), ans.end());
  ans = string(n - 1, '0') + ans;
  return ans;
}
```

