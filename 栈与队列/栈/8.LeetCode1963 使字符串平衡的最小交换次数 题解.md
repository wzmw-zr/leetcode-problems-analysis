# LeetCode1963 使字符串平衡的最小交换次数 题解

## 一、题目描述

给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。

只有能满足下述所有条件的字符串才能称为 平衡字符串 ：

+ 字符串是一个空字符串，或者
+ 字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
+ 字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。

你可以交换 任意 两个下标所对应的括号 任意 次数。

返回使 s 变成 平衡字符串 所需要的 最小 交换次数。

提示：

+ n == s.length
+ 2 <= n <= 10^6
+ n 为偶数
+ s[i] 为'[' 或 ']'
+ 开括号 '[' 的数目为 n / 2 ，闭括号 ']' 的数目也是 n / 2

## 二、分析

### 1. 栈 + 贪心

首先**将所有能够配对的去除**，使用栈完成该任务。

当栈不为空，当前字符为"]"，栈顶元素为"["时，配对成功，出栈。

最后栈中一定是"]]]]....[[[["，问题就变成了使"]]]]....[[[["平衡的最小交换次数，**每次交换最多可以完成2租配对**。



### 2. 平衡字符串的性质 + 贪心

根据平衡字符串的定义可知，**==如果一个字符串是平衡字符串，那么在任何位置i，"["的数量一定大于等于"]"的数量==**。

记录"["和"]"的数量的差值cnt，**如果cnt < 0，意味着"]"比"["多，需要进行一次交换**，而**一次交换最多可以完成两组配对，cnt加2**。



## 三、代码

### 1. 栈 + 贪心

```c++
int minSwaps(string s) {
    stack<char> st;
    for (char c : s) {
        if (st.empty() || c == '[') {
            st.push(c);
        } else {
            if (st.top() == '[') st.pop();
            else st.push(c);
        }
    }
    int cnt = st.size() / 2;
    return cnt / 2 + cnt % 2;
}
```

