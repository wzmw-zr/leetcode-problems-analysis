# LeetCode913 猫和老鼠 题解

## 一、题目描述

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，猫无法移动到洞中（节点 0）。

然后，游戏在出现以下三种情形之一时结束：

+ 如果猫和老鼠出现在同一个节点，猫获胜。
+ 如果老鼠到达洞中，老鼠获胜。
+ 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设**两位玩家都都以最佳状态参与游戏**：

+ 如果老鼠获胜，则返回 1；
+ 如果猫获胜，则返回 2；
+ 如果平局，则返回 0 。



提示：

+ 3 <= graph.length <= 50
+ 1 <= graph[i].length < graph.length
+ 0 <= graph[i][j] < graph.length
+ graph[i][j] != i
+ graph[i] 互不相同
+ 猫和老鼠在游戏中总是移动



## 二、分析

玩家用最佳策略参加游戏，表明这是一道博弈类题目。

**==能够获得完全信息的博弈类问题，胜者是一定的，而这种问题往往使用动态规划求解==**。

**==这道题给我的启发是博弈类问题中，除了操作者所处的状态，操作的轮数也可以成为状态的一部分，用来揭示当前操作者是谁==**。

博弈问题中有三个概念：必胜状态、必败状态、必和状态。

1. 对于特定状态，**如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态、必和状态**。
   + **如果分出胜负，则该特定状态对于获胜方是必胜状态，对于落败方是必败状态**。
   + **如果是平均，则该状态对于双方都是必和状态**。
2. 从特定状态开始，**如果存在一个操作将状态变成对方玩家的必败状态，则当前的玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家成为必胜状态**。
3. 从特定状态开始，**如果所有操作都将状态变成对方玩家的必胜状态，则无论当前的玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态**。
4. 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都是必和状态。
5. **因此，状态转移时需要知道当前的玩家，虽然两者可能因为操作类似而合并成一个操作**。

对于每个玩家，最优策略：

1. 争取将必胜状态留给自己，必败状态留给对方玩家。
2. 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。

很多情况下记忆化搜索是博弈类问题的常用解法，因为记忆化搜索的搜索方向很容易知道，动态规划也是，不过有时候动态规划转移比较困难。



定义状态$dp[mouse][cat][turn]$，表示从老鼠位于节点mouse，猫位于结点cat，游戏进行了turn轮的状态开始，猫和老鼠都进行了最优策略后的游戏结果。

假如游戏初始状态是老鼠位于节点1,猫位于节点2，则$dp[1][2][0]$是从初始状态开始的游戏结果。

动态规划的边界状态：

+ mouse = 0，老鼠躲进洞里，则老鼠获胜，因此对于任意的$dp[0][cat][turn]=1$，该状态是老鼠的必胜状态，猫的必败状态。
+ 如果cat = mouse且mouse ！= 0（猫不能移动到节点0，这个无所谓了），则猫获胜，即如果$mouse=cat$，对任意的turn，有$dp[mouse][cat][turn]=2$。
+ 如果turns >= 2n，则是平均，该状态为双方的必和状态。（鸽巢原理）

如果轮到老鼠移动，则对于老鼠从当前节点移动一次之后可能到达的每个节点，进行如下操作：

+ 如果存在一个节点，老鼠到达该节点之后，老鼠可以获胜，则老鼠到达该节点之后的状态为老鼠的必胜状态，猫的必败状态，因此在老鼠移动之前的当前状态为老鼠的必胜状态。

+ 如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态，但是存在一个节点，老鼠到达该节点之后，结果是平局，则老鼠到达该节点之后的状态为双方的必和状态，因此在老鼠移动之前的当前状态为双方的必和状态。

+ 如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态或必和状态，则老鼠到达任何节点之后的状态都为老鼠的必败状态，猫的必胜状态，因此在老鼠移动之前的当前状态为老鼠的必败状态。

对于猫也是这样的操作，相同的操作逻辑可以只使用一个函数。

对于特定玩家的移动，实现方法如下：

1. 如果当前玩家存在一种移动方法到达非必败状态，则用该状态更新游戏结果。
   + 如果该移动方法到达必胜状态，则将当前状态（移动前的状态）设为必胜状态，结束遍历其他可能的移动。
   + 如果该移动方法到达必和状态，则将当前状态（移动前的状态）设为必和状态，继续遍历其他可能的移动，因为可能存在到达必胜状态的移动方法。

2. 如果当前玩家的任何移动方法都到达必败状态，则将当前状态（移动前的状态）设为必败状态。



## 三、代码

```c++
int wzmw_zr = 0;
bool fuck_plagiarism_system_of_leetcode = true;

using TIII = tuple<int, int, int>;

int dfs(vector<vector<int>> &graph, int x, int y, int turn, map<TIII, int> &mp) {
    if (x == 0) return 1;
    if (x == y) return 2;
    if (turn >= 2 * graph.size()) return 0;
    TIII state(x, y, turn);
    if (mp.count(state)) return mp[state];
    if (turn & 1) {
        int flag = 1;
        for (int t : graph[y]) {
            if (!t) continue;
            int temp = dfs(graph, x, t, turn + 1, mp);
            if (temp == 2) {
                flag = 2;
                break;
            }
            if (temp == 0) flag = temp;
        }
        mp[state] = flag;
    } else {
        int flag = 2;
        for (int t : graph[x]) {
            int temp = dfs(graph, t, y, turn + 1, mp);
            if (temp == 1) {
                flag = 1;
                break;
            }
            if (temp == 0) flag = temp;
        }
        mp[state] = flag;
    }
    return mp[state];
}

int catMouseGame(vector<vector<int>>& graph) {
    map<TIII, int> mp;
    return dfs(graph, 1, 2, 0, mp);
}
```

