# LeetCode600 不含连续1的非负整数 题解

## 一、题目描述

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。

**Constraints:**

- `1 <= n <= 10^9`



## 二、分析

这是一道**典型的数位DP，不过是二进制的**。

设$ones[i]$表示二进制表示长度等于i、无连续1的、最高位为1的数字个数。

设$zeros[i]$表示二进制表示长度等于i、无连续1的，最高位为0的数字个数。

则状态转移方程如下：
$$
zeros[i + 1]=zeros[i] + ones[i]\\
ones[i + 1] = zeros[i]
$$
然后，计算小于等于n的非负整数中二进制表示小于等于n的不含连续1的非负整数的个数。

这样，$ones[i]$就相当于$[2^{i-1},2^i-1]$内无连续1的最高位为1的数字个数。

**不过，数位DP中$dp[i]$一般都是$[0,f(i)]$范围内的满足要求的数字个数**，因此，$dp[i]$表示$[0,2^i-1]$内最高位为1的无连续1的数字个数。

数位DP运用的DP的地方计算的是一些辅助数据，而这提的递归求解部分困扰了我很长时间，原因是处理完n后，进入下一层需要判断次高位$h-1$是否为1：

+ 次高位不为1，$n = n-2^{h-1}$进入下一层。
+ 次高位为1，$n=2^{h-2}-1$，而不是直接全清。。。，因为这样会丢失一部分数据。



## 三、代码

```c++
int dfs(int n, vector<int> &ones) {
    if (n == 0 || n == 1) return ones[n];
    int h = 32 - __builtin_clz(n);
    int ans = ones[h - 1];
    n -= 1 << (h - 1);
    if ((h >= 2) && ((n >> (h - 2)) & 1)) n = (1 << (h - 2)) - 1;
    ans += dfs(n, ones);
    return ans;
}

int findIntegers(int n) {
    vector<int> ones(33, 0);
    vector<int> zeros(33, 0);
    ones[1] = zeros[1] = 1;
    for (int i = 2; i <= 32; i++) {
        zeros[i] = zeros[i - 1] + ones[i - 1];
        ones[i] = zeros[i - 1];
    }
    ones[0] = 1;
    for (int i = 1; i <= 32; i++) ones[i] += ones[i - 1];
    return dfs(n, ones);
}
```



## 四、关于数位DP的思考

数位DP不常见但也不少见，一般来说，接触比较多的是10进制的数位DP，而这道题是2进制的数位DP，由此类推可以解决**k进制的数位DP**问题。

一般来说数位DP解决问题的步骤如下：

+ 先**预处理$dp[i]$或者$dp[i][j]$**，其中i表示所有i位k进制数（可以包含前导0）。
+ 之后**从高位处理到低位（可以理解为从高位到地位的决策，更新可以是递归或者循环判断）**，在处理的过程中**计算中间结果**，很**关键的一个地方是对于低位数据的更新**，有些时候不是简单的直接减法，最好先**列举几个例子找到较好的更新方法**。

而通常数位DP要求的是$[a,b]$范围内满足某种性质的数据，这个问题可以转化成$[0,n]$范围内满足某种性质的数据，然后$f(b)-f(a-1)$即可。



根据官方题解的思路，是**将数位DP通过字典树理解**，比如**k进制的数位DP就对应每个节点的分支数为k的Trie树**，有助于理解数位DP的转移过程与合适的状态定义（这个适合对一个节点及其孩子从下往上理解）。而将数位DP抽象成字典树后，计算过程就是从跟到叶子的访问过程。

