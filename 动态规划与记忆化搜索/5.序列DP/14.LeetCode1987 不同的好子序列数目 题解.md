# LeetCode1987 不同的好子序列数目 题解

## 一、题目描述

给你一个二进制字符串 `binary` 。 `binary` 的一个 **子序列** 如果是 **非空** 的且没有 **前导** **0** （除非数字是 `"0"` 本身），那么它就是一个 **好** 的子序列。

请你找到 `binary` **不同好子序列** 的数目。

- 比方说，如果 `binary = "001"` ，那么所有 **好** 子序列为 `["0", "0", "1"]` ，所以 **不同** 的好子序列为 `"0"` 和 `"1"` 。 注意，子序列 `"00"` ，`"01"` 和 `"001"` 不是好的，因为它们有前导 0 。

请你返回 `binary` 中 **不同好子序列** 的数目。由于答案可能很大，请将它对 `10^9 + 7` **取余** 后返回。

一个 **子序列** 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。

**提示：**

- `1 <= binary.length <= 10^5`
- `binary` 只含有 `'0'` 和 `'1'` 。



## 二、分析

### 1. 序列DP

这题考察的是序列DP，序列DP通常使用的状态定义dp[i]\[...]：(1)前i个元素构成的满足条件的子序列 或者 (2)以第i个元素结尾的满足条件的子序列。这里我们**定义状态$dp[i+1][j]$表示前i个元素构成的以j结尾的好子序列个数**，**==状态转移需要考虑以第i个元素结尾且最后为j的好子序列个数，以及前i个元素构成的最后为j的好子序列个数，两者有重叠的部分，如何处理是关键==**。

假设$binary[i]=1$，则以第i个元素结尾且最后为1的好子序列个数为$dp[i][0]+dp[i][1]+1$，此外，以及前i-1个元素构成的最后为1的好子序列个数为$dp[i][1]$，但是，这两者有重合，将前i-1个元素构成的最后为1的好子序列的最后一个1换成第i个位置的1就是重合的子序列，这部分数量为$dp[i][1]$，因此，$binary[i]=1$的状态转移方程为：
$$
dp[i+1][0]=dp[i][0]\\
dp[i+1][1]=dp[i][0] + dp[i][1] + 1
$$
同理，$binary[i]=0$时的状态转移方程：
$$
dp[i+1][0]=dp[i][0]+dp[i][1]\\
dp[i+1][1]=dp[i][1]
$$
另外，需要考虑单独的0的情况。



## 三、代码

### 1. 序列DP

```c++
long MOD = 1e9 + 7;

int numberOfUniqueGoodSubsequences(string binary) {
  int n = binary.size();
  long dp[n + 1][2];
  memset(dp, 0, sizeof(dp));
  int zero = 0;
  for (int i = 0; i < n; i++) {
    char c = binary[i];
    if (c == '0') {
      zero = 1;
      dp[i + 1][0] = (dp[i][0] + dp[i][1]) % MOD;
      dp[i + 1][1] = dp[i][1];
    } else {
      dp[i + 1][0] = dp[i][0];
      dp[i + 1][1] = (1 + dp[i][0] + dp[i][1]) % MOD;
    }
  }
  return (dp[n][0] + dp[n][1] + zero) % MOD;
}
```

