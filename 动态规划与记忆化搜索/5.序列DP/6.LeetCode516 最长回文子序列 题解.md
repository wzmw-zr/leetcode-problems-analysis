# LeetCode516 最长回文子序列 题解

## 一、题目描述

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成



## 二、分析

设$dp[i][j]$为$[i,j]$区间内的最长回文子序列长度，状态转移方程：
$$
dp[i][j]=\left\{
\begin{matrix}
\max\{dp[i+1][j],dp[i][j-1]\} \quad s[i] \neq s[j]\\
\max\{dp[i+1][j],dp[i][j-1],dp[i+1][j-1]+2\}\quad s[i] == s[j]
\end{matrix}
\right.
$$
注意边界条件，最好初始化$dp$全为1。

同时这也是一道经典的**区间DP**题目，之所以可以使用区间DP求解，是因为在给定一个回文串的基础上，如果在回文串的边缘分别添加两个新的字符，可以通过判断两个字符是否相等来得知新串是否会问。即，**使用小区间的回文状态可以推导出大区间的回文状态值**。

> **从图论意义出发就是，任何一个长度为`len`的回文串，必然由「长度为`len-1`」或「长度为`len-2`」的回文串转移而来。**
>
> **两个具有公共回文部分的回文串之间存在拓扑序（==存在由「长度较小」回文串指向「长度较大」回文串的有向边==）**。
>
> 通常区间DP问题都是这样，常见的基本流程为：
>
> 1. 从小到大枚举区间大小`len`。
> 2. 枚举区间左端点`l`，同时根据区间大小`len`和左端点`l`计算区间右端点`r = l + len - 1`。
> 3. 通过状态转移方程求`f[l][r]`的值。



## 三、代码

```c++
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++) dp[i][i] = 1;
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) dp[i][i + 1] = 2;
    }
    for (int l = 3; l <= n; l++) {
        for (int i = 0; i < n - l + 1; i++) {
            if (s[i] != s[i + l - 1]) dp[i][i + l - 1] = max({dp[i + 1][i + l - 1], dp[i][i + l - 2]});
            else dp[i][i + l - 1] = max({dp[i + 1][i + l - 2] + 2, dp[i + 1][i + l - 1], dp[i][i + l - 2]});
        }
    }
    return dp[0][n - 1];
}
```

