# LeetCode516 最长回文子序列 题解

## 一、题目描述

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成



## 二、分析

设$dp[i][j]$为$[i,j]$区间内的最长回文子序列长度，状态转移方程：
$$
dp[i][j]=\left\{
\begin{matrix}
\max\{dp[i+1][j],dp[i][j-1]\} \quad s[i] \neq s[j]\\
\max\{dp[i+1][j],dp[i][j-1],dp[i+1][j-1]+2\}\quad s[i] == s[j]
\end{matrix}
\right.
$$
注意边界条件，最好初始化$dp$全为1。



## 三、代码

```c++
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++) dp[i][i] = 1;
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) dp[i][i + 1] = 2;
    }
    for (int l = 3; l <= n; l++) {
        for (int i = 0; i < n - l + 1; i++) {
            if (s[i] != s[i + l - 1]) dp[i][i + l - 1] = max({dp[i + 1][i + l - 1], dp[i][i + l - 2]});
            else dp[i][i + l - 1] = max({dp[i + 1][i + l - 2] + 2, dp[i + 1][i + l - 1], dp[i][i + l - 2]});
        }
    }
    return dp[0][n - 1];
}
```

