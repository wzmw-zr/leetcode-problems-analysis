# LeetCode2167 移除所有载有违禁货物车厢所需的最少时间 题解

## 一、题目描述

给你一个下标从 **0** 开始的二进制字符串 `s` ，表示一个列车车厢序列。`s[i] = '0'` 表示第 `i` 节车厢 **不** 含违禁货物，而 `s[i] = '1'` 表示第 `i` 节车厢含违禁货物。

作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：

1. 从列车 **左** 端移除一节车厢（即移除 `s[0]`），用去 1 单位时间。
2. 从列车 **右** 端移除一节车厢（即移除 `s[s.length - 1]`），用去 1 单位时间。
3. 从列车车厢序列的 **任意位置** 移除一节车厢，用去 2 单位时间。

返回移除所有载有违禁货物车厢所需要的 **最少** 单位时间数。

注意，空的列车车厢序列视为没有车厢含违禁货物。

**提示：**

- `1 <= s.length <= 2 * 10^5`
- `s[i]` 为 `'0'` 或 `'1'`



## 二、分析

这种可以看作是**"可以选择对两端以及中间进行操作类型的DP"**，这类问题可以**转化/分解成前缀DP和后缀DP，枚举分界线进行计算**。



## 三、代码

```c++
int minimumTime(string s) {
  int n = s.size();
  vector<int> dp1(n + 1, 0), dp2(n + 1, 0);
  for (int i = 0; i < n; i++) {
    if (s[i] == '0')
      dp1[i + 1] = dp1[i];
    else
      dp1[i + 1] = min({dp1[i] + 2, i + 1});
  }
  for (int i = n - 1; i >= 0; i--) {
    if (s[i] == '0')
      dp2[i] = dp2[i + 1];
    else
      dp2[i] = min({dp2[i + 1] + 2, n - i});
  }
  int ans = INT32_MAX;
  for (int i = 0; i < n; i++) 
    ans = min(ans, dp1[i + 1] + dp2[i + 1]);
  return ans;
}
```

