# LeetCode639 解码方法II 题解

## 一、题目描述

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：

"AAJF" 对应分组 (1 1 10 6)
"KJF" 对应分组 (11 10 6)
注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。

除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。

由于答案数目可能非常大，返回对 10^9 + 7 取余 的结果。

**提示：**

- `1 <= s.length <= 10^5`
- `s[i]` 是 `0 - 9` 中的一位数字或字符 `'*'`



## 二、分析

这是一道比较明显的线性DP问题，可以有两种解法。

### 1. 分类讨论DP

设$dp[i]$是第i个字符为止的解码方法数，根据$s[i]$和$s[i-1]$分类讨论，情况比较多，略。

### 2. 枚举DP

设$dp[i][x]$是第i个字符为止以$x$结尾的方法数，根据$s[i]$和$s[i-1]$分类讨论。



## 三、代码

### 1. 分类讨论DP

```c++
const long MOD = 1e9 + 7;

int numDecodings(string s) {
    if (s[0] == '0') return 0;
    int n = s.size();
    long dp[n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = 1;
    dp[1] = s[0] == '*' ? 9 : 1;
    for (int i = 1; i < n; i++) {
        if (s[i] == '*') {
            dp[i + 1] += (dp[i] * 9) % MOD;
            if (s[i - 1] == '*' || s[i - 1] == '1') dp[i + 1] = (dp[i + 1] + dp[i - 1] * 9) % MOD;
            if (s[i - 1] == '*' || s[i - 1] == '2') dp[i + 1] = (dp[i + 1] + dp[i - 1] * 6) % MOD;
        } else if (s[i] == '0') {
            if (s[i - 1] == '*' || s[i - 1] == '1') dp[i + 1] = (dp[i + 1] + dp[i - 1]) % MOD;
            if (s[i - 1] == '*' || s[i - 1] == '2') dp[i + 1] = (dp[i + 1] + dp[i - 1]) % MOD;
        } else if (s[i] <= '6') {
            dp[i + 1] = dp[i];
            if (s[i - 1] == '*' || s[i - 1] == '1') dp[i + 1] = (dp[i + 1] + dp[i - 1]) % MOD;
            if (s[i - 1] == '*' || s[i - 1] == '2') dp[i + 1] = (dp[i + 1] + dp[i - 1]) % MOD;
        } else {
            dp[i + 1] = dp[i];
            if (s[i - 1] == '*' || s[i - 1] == '1') dp[i + 1] = (dp[i + 1] + dp[i - 1]) % MOD;
        }
    }
    return dp[n];
}
```



