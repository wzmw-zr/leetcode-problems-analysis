# LeetCode769 最多能完成排序的块 题解

## 一、题目描述

给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。

我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。

返回数组能分成的最多块数量。

**提示:**

- `n == arr.length`
- `1 <= n <= 10`
- `0 <= arr[i] < n`
- `arr` 中每个元素都 **不同**



## 二、分析

### 1. 「循环不变量」

根据题意可以知道：

+ 定理一：对于某个块 A，它由块 B 和块 C 组成，即 A = B + C。如果块 B和块 C 分别排序后都与原数组排序后的结果一致，那么块 A 排序后与原数组排序后的结果一致。
+ 定理二：对于某个块 A，它由块 B和块 C组成，即 A = B + C。如果块 A和块 B 分别排序后都与原数组排序后的结果一致，那么块 C排序后与原数组排序后的结果一致。

题目需要找到的是每段元素和原数组对应段排序后相同的段，可以认为是循环不变量，可以采用如下方法：

+ 使用哈希表等记录元素，如果两段元素相同，则找到一段循环不变量。
+ 容易得知一段[l,r]的循环不变量的最小值为l，最大值为r，所以可以通过统计一段子数组的最大值最小值来判断。进一步地，确定了一段的最大值为r，实际上也就确定了一个循环不变量。



## 三、代码

### 1. 「循环不变量」

```c++
int maxChunksToSorted(vector<int>& arr) {
  int n = arr.size();
  int ind = 0, ans = 0;
  while (ind < n) {
    set<int> st1, st2;
    do {
      st1.insert(ind);
      st2.insert(arr[ind]);
      ind++;
    } while (ind < n && st1 != st2);
    ans++;
  }
  return ans;
}
```



