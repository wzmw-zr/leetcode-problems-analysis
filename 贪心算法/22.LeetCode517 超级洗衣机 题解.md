# LeetCode517 超级洗衣机 题解

## 一、题目描述

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。



**提示：**

- `n == machines.length`
- `1 <= n <= 10^4`
- `0 <= machines[i] <= 10^5`



## 二、分析

**这题是又一种贪心算法的题目**。

首先计算所有洗衣机的衣服之和，看是否能被洗衣机数量整除，不能整除则返回-1 。

然后关于移动次数问题，直观来来看，对于位置i的点，其左右两部分的和为$x_1,x_2$，最终平均分配后的和为$y_1,y_2$。可以发现，$x_j < y_j$的话，就一定会向i进行次移动$y_j - x_j$操作（当然也可以规定为$x_j  >y_j$需要向i进行$x_j - y_j$次移动操作），即只有当一侧数量衣服数量小于最终数量时，向该侧进行移动，因此，需要的是$max(y_j-x_j,0)$，所以最终的答案是所有i位置的$max(y_1-x_1,0)+max(y_2-x_2,0)$中的最大值$cnt$，这个从直觉上来说是正确的，但是还需要精确的证明。

正确的证明步骤：

**在没有无效传输的情况下（即同一件衣服不能左右横跳）**，如果最终的最小移动次数为$ans$，可以确定$ans\ge cnt$，接下来就是证明$ans\le cnt$。

使用反证法，设$ans>cnt$，而这只有当一个位置有0时才会出现，可以继续证明取得ans的位置的衣服数不为0  ，进而得到$ans \le cnt$。(**但是这一点我暂时还是没能想的很透彻。。。**)

> 计算某台洗衣机的「最小运输衣服数量」为经过当前机器的衣服数量（每次只能运输一件衣服），其值等于「起始左边衣服总量 与 最终左边衣服总量 的差值」+「起始右边衣服总量 与 最终右边衣服总量 的差值」，这里的差值都需要与 0 取 max 代指缺少衣服的数量（因为如果是多余数量的话，可以通过同时传输来满足增加缺少的一边，减少多余的一边）。

**一个猜测：==也许这种需要通过移动来进行分配的问题，可以通过分析「传输经过每个位置的物品数」作为解题的突破口==。**

这题更直接的理解：

+ **由于一次可以多个洗衣机送衣服，所以我们只要找要送最多次的洗衣机即可。**
+ **由于一个洗衣机往两边都送的话，要叠加统计次数，所以特殊处理。**



## 三、代码

```c++
int findMinMoves(vector<int> &machines) {
    int n = machines.size();
    int sum = 0;
    for (int x : machines) sum += x;
    if (sum % n) return -1;
    int avg = sum / n;
    vector<int> pre(n + 1, 0);
    for (int i = 0; i < n; i++) pre[i + 1] += pre[i] + machines[i];
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, max(0, i * avg - pre[i]) + max(0, (n - i - 1) * avg - (sum - pre[i + 1])));
    }
    return ans;
}
```

