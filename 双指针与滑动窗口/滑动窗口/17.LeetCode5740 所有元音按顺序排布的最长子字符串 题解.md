# LeetCode5740 所有元音按顺序排布的最长子字符串 题解

## 一、题目描述

当一个字符串满足如下条件时，我们称它是 美丽的 ：

所有 5 个英文元音字母（'a' ，'e' ，'i' ，'o' ，'u'）都必须 至少 出现一次。
这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 'a' 都在 'e' 前面，所有的 'e' 都在 'i' 前面，以此类推）
比方说，字符串 "aeiou" 和 "aaaaaaeiiiioou" 都是 美丽的 ，但是 "uaeio" ，"aeoiu" 和 "aaaeeeooo" 不是美丽的 。

给你一个只包含英文元音字母的字符串 word ，请你返回 word 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。

子字符串 是字符串中一个连续的字符序列。

**提示：**

- `1 <= word.length <= 5 * 105`
- `word` 只包含字符 `'a'`，`'e'`，`'i'`，`'o'` 和 `'u'` 。



## 二、分析

### 1. 滑动窗口

暴力就是枚举所有子字符串看是否满足情况，不过很容易发现使用滑动窗口。这里需要记录滑动窗口的状态，这里是一个记录元音数量的哈希表，当前目标字母，状态转移规则：

+ 遇到字符和目标字符相同，目标字符数量 + 1。
+ 否则，遇到字符是目标字符的下一个字符，更新目标字符。
+ 否则，判断当前目标字符是最后一个元音字符，和最终答案比较; 然后清空哈希表，如果转移到了'a'，从该位置开始; 否则，从下一个位置开始。

**==这道题建立了滑动窗口与有限状态自动机之间的联系，滑动窗口可以认为是DFA的一种表现形式，维护一个状态，当新的元素来时进行状态转移==**。

(从某种意义上，这道题目就是构建一个DFA，处理流式数据，同时也可以看出，滑动窗口可以用于处理流式数据。)



## 三、代码

```c++
int longestBeautifulSubstring(string word) {
    char ch[5] = {'a', 'e', 'i', 'o', 'u'};
    int ind = 0;
    int l = 0, r = 0;
    int ans = 0;
    int cnt[5] = {0, 0, 0, 0, 0};
    while (word[r]) {
        if (word[r] == ch[ind]) r++, cnt[ind]++;
        else if (ind < 4 && word[r] == ch[ind + 1] && cnt[ind]) {
            r++;
            ind++;
            cnt[ind]++;
        } else {
            if (ind == 4) ans = max(ans, r - l);   
            if (word[r] == 'a') l = r;
            else l = ++r;
            memset(cnt, 0, sizeof(cnt));
            ind = 0;
        }
    }
    if (ind == 4) ans = max(ans, r - l);
    return ans;
}
```

