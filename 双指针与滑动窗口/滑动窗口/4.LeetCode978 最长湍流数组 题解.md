# LeetCode978 最长湍流数组 题解

## 一、题目描述

当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：

+ 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
+ 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。

也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

返回 A 的最大湍流子数组的长度。



## 二、分析

这道题的暴力解法是枚举所有子数组，显然存在**重复子问题和不必要子问题**计算，可以使用**滑动数组**求解。

这里**滑动数组维护的信息**是**上一次的相邻数字的大小关系**。

> 对滑动数组过程的理解：
>
> + **滑动数组需要维护一个信息**，该**信息在滑动窗口扩张和缩小时会更新**。
>
> + 但是这个信息不一定是我们最终的答案，我们会**在窗口缩小时和最后一个窗口**获得一些数据形成**最终的答案**。
>
>   > 滑动窗口的左右边界也是滑动窗口维护的信息。
>
> + 滑动窗口的扩张就是右边界增加，而左边界的增加可能是跨度为1，也可能是更大的跨度，即**滑动窗口的左边界移动规则可以是多样的。**
>
> + 因此，滑动窗口也就成了一个算法框架。

也可以使用**动态规划**求解，dp[i]代表以i结尾的最长湍流子数组长度，**这是与奇偶项数问题，常常构造$len\times2$数组**。

## 三、代码

### 1. 滑动窗口

```c++
int maxTurbulenceSize(vector<int>& arr) {
    if (arr.size() == 1)  return 1;
    int n = arr.size(), l = 0, r = 1, ans = 1, status = 0;
    if (arr[0] == arr[1]) l = 1, status = 0;
    else if (arr[0] < arr[1]) status = -1;
    else status = 1;
    while (r < n - 1) {
        if (arr[r] == arr[r + 1]) ans = max(ans, r - l + 1), l = r + 1, statu
        else if (arr[r] < arr[r + 1]) {
            if (status == -1) ans = max(ans, r - l + 1), l = r;
            else status = 1;
        } else {
            if (status == 1) ans = max(ans, r - l + 1), l = r;
            else status = -1;
        }
        r++;
    }
    ans = max(ans, r - l + 1);
    return ans;
}
```

