# LeetCode424 替换后的最长重复字符 题解

## 一、题目描述

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意：字符串长度 和 k 不会超过 $10^4$。



## 二、分析

这道题一开始我没有思路，并且也没有想到暴力解法，而这道题目的暴力解法是**除了深搜之外的又一类用于字符串暴力方法**：**==枚举输入字符串的所有子串==**。

+ 如果子串中所有字符都一样，就考虑更长的子串。
+ 如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，应当替换到出现次数最多字符以外的字符。

有了这种暴力解法，考虑优化方向：

+ **做了重复的工作**，子串之间有很多重合的部分。
+ **做了没有必要的工作**：
  + 如果找到了一个长度为L且替换k个字符后全部相等的字符串，就没必要考虑长度小于等于L的子串。
  + 如果找到了一个长度为L且替换k个字符后不能全部相等的子串，**左边界相同、长度更长的子串一定不符合要求**。

> 如果只是重复的工作可以考虑DP，但是做了没有必要的工作，那就需要考虑其他方法了。

而关于枚举子串的一些优化方向中，**滑动数组可以解决做了没必要的工作的缺点**。而这也是使用**滑动数组的一类典型题目**。

> 至于怎么想到用滑动数组，**因为有序地处理子串/子区间是解决不必要工作的一个好方法**。



## 三、代码

```c++
int characterReplacement(string s, int k) {
    int n = s.size();
    vector<vector<int>> cnt(n + 1, vector<int>(26, 0));
    int ans = min(k, n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 26; j++) cnt[i + 1][j] = cnt[i][j];
        cnt[i + 1][s[i] - 'A']++;
    }
    int l = 1, r = k + 1;
    while (r <= n) {
        int max_cnt = 0;
        for (int i = 0; i < 26; i++) 
            max_cnt = max(max_cnt, cnt[r][i] - cnt[l - 1][i]);
        if (max_cnt + k >= r - l + 1) ans = max(ans, r - l + 1), r++;
        else l++;
    }
    return ans;
}
```

当然，这里还有优化了时空复杂度的解法，还是滑动数组思路。

```c++
int characterReplacement(string s, int k) {
    //记录当前窗口字母出现的个数
    vector<int> counts(26, 0); 
    // maxCount记录字符出现次数最多那个字符的次数，res储存最大的窗口大小
    int left = 0, res = 0, maxCount = 0; 
    for(int i = 0; i < s.size(); i ++) {
        counts[s[i] - 'A'] ++;
        // 比较之前记录的最大数 和 当前字符的数量
        maxCount = max(maxCount, counts[s[i] - 'A']); 
        // 若当前窗口大小 减去 窗口中最多相同字符的个数 大于 k 时
        while(i - left + 1 - maxCount > k){ 
            // 将窗口最左边的字符 在计数数组中减1
            counts[s[left] - 'A'] --; 
            left ++; // 滑动窗口
        }
        res = max(res, i - left + 1);
    }
    return res;
}
```

